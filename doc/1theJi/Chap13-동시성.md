# 동시성
  
> **객체는 처리의 추상화다. 스레드는 일정의 추상화다.** </br>
_- 제임스 O. 코플리_
  
- 스레드를 하나만 실행하는 코드, 겉으로 보기에는 멀쩡하나 깊숙한 곳에 문제가 있는 다중쓰레드 코드는 짜기 쉽다.
	- 시스템이 부하를 받기 전까지 멀쩡하게 돌아간다.

## 동시성이 필요한 이유 ?
- 동시성은 결합 <sup>coupling</sup>을 없애는 전략이다.
	- 무엇 <sup>what</sup>과 언제<sup>when</sup>를 분리하는 전략
	- 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다.
	- 단일 스레드 프로그램을 디버깅하는 프로그래머는 정지점<sup>breakpoint</sup>을 정한후 어느지점에서 걸렸는지 살펴보면서 시스템 상태 파악
- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다
	- 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램으로 보임
> 무엇과 언제를 분리하면 시스템을 이해하기가 쉽고 문제를 분리하기도 쉽다.

### 미신과 오해
- 동시성은 항상 성능을 높여준다.(X)
	- 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아짐
- 동시성을 구현해도 설계는 변하지 않는다(X)?
	- 단일 스레드는 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 일반적으로 무엇고 언제를 분리하면 시스템 구조가 크게 달라진다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.(X)
	- 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드랑 등과 같은 문제를 피할 수 있는지를 알아야 한다.
- 동시성은 다소 부하를 유발한다.(O)
	- 성능 측면에서 부하가 걸리며, 코드도 더 짜야 한다.
- 동시성은 복잡하다.(O)
	- 간단한 문제라도 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.(O)
	- 진짜 결함으로 간주되지 않고 일회성 문제<sup>작은문제(또는 결함, gliches)</sup>로 여겨 무시하기 쉽다
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.(O)


## 난관
```java
public class X {
	private int lastIdUsed;

	public in getNextId() {
		return ++lastIdUsed;
	}
}
```
> 동시성을 구현하기 어려운 이유? <br> - 잘못된 결과를 내놓는 일부 경로때문이다!

## 동시성과 방어 원칙
> 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술

### 단일 책임 원칙 <sup>Single Responsibility Principle, SRP</sup>
> 주어진 메서드/클래스/컴포넌트를 변결할 이유가 하나여야 한다.
- 동시성은 복잡한 하나만으로도 따로 분리해야한다.
- 동시성과 관련 코드는 다른 코드와 분리해야한다.
- 동시성을 구현할때 고려사항
	- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
	- 동시성 코드에는 돋ㄱ자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다.
	- 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다

<b> 권장사항 : 동시성 코드는 다른 코드와 분리하라 <b>

### 따름 정리<sup>corollary</sup>: 자료 범위를 제한하라
- 객체 하나를 공유한 후 동일 필드를 수정하던 두 스레드가 서로 간섭하므로 예상지 못한 결과 초래
	- 공유 객체를 사용하는 코드 내 임계영역 <sup>critical section</sup>을 <b>synchronized</b> 키워드로 보호 권장
	- 임계영역의 수를 줄이는 기술이 중요하고 공유 자료를 수정하는 위치가 많을수록 초래할 문제점이 많아짐
		- 보호할 임계 영역을 빼먹는다 --> <b>공유 자료를 수정하는 모든 코드를 망가 뜨린다</b>
		- 모든 임계영역을 올바로 보호했는지(DRY 위반<sup>불필요한 반복을 제거하라</sup>) 확인하느라 똑같은 노력과 수고를 반복한다
		- 어려운 버그가 더욱 찾기가 어려워진다.

**권장사항**: *자료를 캡슐화<sup>encapsulation</sup>하라. 공유 자료를 최대한 줄여라*

### 따름 정리: 자료 사본을 사용하라
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일좋음
	- 객체를 복사해 읽기 전용으로 사용하는 방법
	- 각 스레드가 객체를 복사해서 사용한 후, 한 스레드만 해당 사본에서 결과를 가져오는 방법
- 공유 객체를 피하는 방법이 있다면 코드가 문제를 일으킬 가능성이 낮아짐
- 사본으로 동기화를 피할수 있다면 내부 잠금(문제점?)을 없애 절약한 수행시간이 사본생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다	

### 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 자신만의 세상에 존재하는 스레드를 구현. 즉, 다른 스레드와 자료를 공유하지 않는다
	- HttpServlet 클레스에서 파생한 클래스는 모든 정보를 doGet/doPost 메소드 --> 각 서블릿은 자신이 독자적인 시스템에서 동작하는 양 요청을 처리한다.

**권장사항** : *독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라*	


## 라이브러리를 이해하라
> 자바 5는 동시성 측면에서 이전 보다 많이 나아졌고, 자바 5로 스레드 코드로 구현할때 고려해야할 사항
- 스레드 환경에 안전한 컬렉션을 사용 > 자바 5부터 제공
- 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용
- 가능하다면 스레드가 차단<sup>blocking</sup> 되지 않는 방법을 사용
- 일부 클래스 라이브러리는 스레드에 안전하지 못함

### 스레드 환경에 안전한 컬렉션
java.util.concurrent 
|클레스명|설명|
|---|---|
|ReentrantLock|한 메서드에서 잠그고 다른 메서드에서 푸는 락(lock)이다|
|Semaphore|전형적인 세마포다. 개수(count)가 있는 락이다.|
|CountDownLatch|지정한 수만큼 이벤트가 발생하고 나서야 대기 중인 스레드를 모두 해제하는 락이다. <br/>모든 스레드에서 동시에 공평하게 시작할 기회를 준다|

**권장사항** : *java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks 를 익혀라*

## 실행 모델을 이해하라
|이름|설명|
|---|---|
|한정된 자원<sup>Bound Resources</sup>|다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. </br> 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예다|
|상호 배제<sup>Mutual Exclusion</sup>|한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.|
|기아<sup>Starvation</sup>|한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.</br> 예를 들어, 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이어질 경우, 긴 스레드가 기아 상태에 빠진다.|
|데드락<sup>Deadlock</sup>|여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.|
|라이브락<sup>Livelock</sup>|락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명(resonance)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.|

### 생산자-소비자<sup>Producer-Consumer</sup>
<img src="https://user-images.githubusercontent.com/34755287/54337393-1ee43880-4672-11e9-9ca9-b9d0b414b833.png">

- 생산자
	- 하나 이상 생산자 스레드가 정보를 생성해 버퍼<sup>buffer</sup>나 대기열<sup>queue</sup>에 넣는다.
	- 생산자 스레드는 대기열에 빈공간이 있어야 정보를 채운다 (즉, 빈 공간이 생길 때까지 기다린다.)
- 소비자
	- 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다.
	- 소비자 스레드는 대기열에 정보가 있어야 가져온다 (즉, 정보가 채워질 때까지 기다린다)
- 자원
	- 생산자 스레드와 소비자 스레드가 사용하는 대기열은 <b>한정된 자원</b>이다.
	- 대기열을 올바로 사용하고자 생산자 스레드와 소비자 스레드는 서로에게 시그널을 보낸다	
> 잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게 시그널을 기다릴 가능성이 존재

### 읽기-쓰기<sup>Readers-Writers</sup>
- 읽기 스레드와 쓰기 스레드가 같은 공유자원을 사용할때 처리율<sup>throughput</sup>이 문제가 된다
	- 처리율을 강조하면 기아<sup>starvation</sup>현상이 생기거나 오래된 정보가 쌓이고, 갱신을 허용하면 처리율에 영향을 미침
> 읽기 스레드의 요구와 쓰기 스레드의 요구를 적절히 만족시켜 처리율도 적당히 높이고 기아도 방지하는 해법이 필요

### 식사하는 철학자들<sup>Dining Philosophers</sup>

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/An_illustration_of_the_dining_philosophers_problem.png/220px-An_illustration_of_the_dining_philosophers_problem.png">
철학자 - 스레드, 포크 - 자원

- 기업 애플리케이션은 여러 프로세스가 자원을 얻으려고 경쟁
	- 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 겪는다

**권장사항**: *위 세가지에 대한 알고리즘과 각 해법을 이해하라*

## 동기화 하는 메서드 사이에 존재하는 의존성을 이해하라 
- 동기화하는 메서드 사이에서 의존성이 존재하면 동시성 코드에서 찾아내기 어려운 버그가 생김 
- 자바 언어는 개별 메서드를 보호하는 synchronized라는 개념 지원
- 공유 클레스 하나에 동기화된 메서드가 여럿이라면 구현이 올바른지 다시 확인

**권장사항**: *공유 객체 하나에는 메서드 하나만 사용하라*

- 공유 객체 하나에 여러 메서드가 필요할 때 방법
	- 클라이언트에서 잠금 : 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠그고, 마지막 메서드를 호출할 때까지 잠금을 유지한다.
	- 서버에서 잠금 : "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는"메서드를 구현하고, 클라이언트는 이 메서드를 호출한다.
	- 연결<sup>Adapted</sup> 서버 : 잠금을 수행하는 중간 단계를 생성. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않는다.

## 동기화하는 부분을 작게 만들어라
- 자바에서 synchronized 키워드를 사용하면 락을 설정하는데, 락으로 감싼 코드영역은 한번에 한 스레드만 실행이 가능하나 스레드를 지연시키고 부하를 가중시킨다.
- 임계영역<sup>critical section</sup>은 반드시 보호하되 임계 영역 수를 최대한 줄여야한다.
	- 필요 이상으로 임계 영역 크기를 키우면 스레드 간에 경쟁이 늘어나고 프로그램 성능이 떨어진다.

**권장사항**: *동기화하는 부분을 최대한 작게 만들어라*

## 올바른 종료 코드는 구현하기 어렵다
- 깔끔하게 종료하는 코드는 올바르게 구현하기 어려운데, 흔희 발생하는 문제가 데드락(여러스레드가 서로 끝나기를 기다림)이다.
- 깔끔하게 종료하는 다중 스레드 코드를 짜야한다면 시간을 투자해 올바로 구현해야함

**권장사항**: *종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라, 생각보다 오래걸린다. 생각보다 어려우므로 이미 나온 알고리즘을 검토하라.*

## 스레드 코드 테스트하기
- 잘 작성된 테스트는 위험을 최소화 할수 있지만, 같은 코드와 같은 자원을 사용하는 스레드가 둘 이상으로 늘어나면, 상황(충분한 테스트는 위험을 낮춤)은 급격하게 복잡해진다.

**권장사항**: *문제를 노출하는 테스트 케이스를 작성하라. 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라. 테스트 실패하면 원인을 추적하라. 다시 돌렸더니 통과한다는 이유로 그냥 넘어가면 절대로 안된다.*

- 스레드 둘이상 늘어났을경우의 구체적인 지침
	- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
	- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
	- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
	- 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
	- 프로세서 수보다 많은 스레드를 돌려보라
	- 다른 플랫폼에서 돌려보라
	- 코드에 보조 코드<sup>instrument</sup>를 넣어 돌려라. 강제로 실패를 일으키게 해보라

### 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라.
- 실패를 재현하기 어렵고, 스레드 코드에 잠입한 버그는 수천/수백만 번에 한번씩 드러나기도 한다
- 많은 개발자가 우주선, 하드웨어 문제, 단순한 '일회성' 문제로 치부하고 무시한다
- '일회성' 문제를 계속 무시한다면 잘못된 코드 위에 코드가 계속 쌓인다.
**권장사항**: *시스템 실패를 '일회성'이라 치부하지 마라.*

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
- 스레드가 호출하는 POJO<sup>Plain Old Java Object</sup>를 만들고, 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인한다.
**권장사항**: *스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅 하지말고, 스레드 환경 밖에서 코드를 올바르게 돌려라*

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라.
- 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다.
- 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
- 테스트 코드를 빨리, 천천히, 다양한 속도록 돌려본다.
- 반복 테스트가 가능하도록 테스트 케이스를 작성한다.
**권장사항**: *다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라*

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
- 적절한 스레드 개수를 파악하려면 상당한 시행착오가 필요
- 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구
- 스레드 개수를 조율하기 쉽게 코드 구현
- 프로그램이 돌아 가는 도중에 스레드 개수를 변경하는 방법 고려
- 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드 고민

### 프로세서 수보다 많은 스레드를 돌려보라
- 시스템이 스레드를 스와핑<sup>swapping</sup>할 때도 문제가 발생
	- 프로세서 수보다 많은 스레드를 돌릴경우 스와핑 발생
	- 스와핑이 잦을수록 입계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워짐

### 다른 플랫폼에서 돌려보라
- 운영체제마다 스레드를 처리하는 정책이 달라 결과가 달라질 수 있다.
- 다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다.
**권장사항**: *처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라.*

### 코드에 보조 코드<sup>instrument</sup>를 넣어 돌려라. 강제로 실패를 일으키게 해보라
- 보조코드를 추가해 코드가 실행되는 순서를 바꿔준다
	- Object.wait(), Object.sleep(), Object.yield(), Object.priority()
- 각 메소드는 스레드 실행되는 순서에 영향을 미치고 버그가 드러날 가능성도 높아짐
- 보조코드 추가하는 방법
	- 직접 구현하기
	- 자동화
#### 직접 구현하기
```java
public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        String url = urlGenerator.next();
        Thread.yield(); // 테스트를 위해 추가되었다.
        updateHasNext();
        return url;
    }
    return null;
}
```
- 문제점
	- 보조 코드를 삽입할 적정 위치를 직접 찾아야한다.
		- 실행할 때마다 설정을 바꿔줄 방법 필요
	- 어떤 함수를 어디서 호출해야 적당한지 어떻게 알까?
	- 배포 환경에 보조코드를 그대로 남겨두면 프로그램 성능이 떨어진다.
		- 배포 환경이 아니라 테스트 환경에서 보조 코드를 실행할 방법이 필요
	- 무작위적이다. 오류가 들어날지도 모르고 드러나지 않을지도 모르고, 드러나지 않을 확률이 더높다

#### 자동화
- AOF<sup>Aspect-Oriented Framework</sup>
- CGLIB
- ASM
```java
public class ThreadJigglePoint {
    public static void jiggle() { }
}

public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        ThreadJiglePoint.jiggle();
        String url = urlGenerator.next();
        ThreadJiglePoint.jiggle();
        updateHasNext();
        ThreadJiglePoint.jiggle();
        return url;
    }
    return null;
}
```
 ThreadJiglePoint.jiggle() : '아무 동작하지않기', 'sleep', 'yield'등을 무작위로 호출
- ThreadJiglePoint 클레스를 구현하는 방법
	- jiggle()메서드를 비워두고 배포 환경에 사용
	- nop,sleep,yield 등을 테스트 환경에서 수행
- ConTest

**권장사항**: *흔들기 기법(매번 다른순서로 실행)을 사용해 오류를 찾아내라.*

## 결론
- 다중 스레드는 올바르게 구현하기 어려우므로, 작성한다면 각별히 꺠끗하게 코드를 짜야한다. 
- SRP<sup>Single Responsibility Principle</sup>를 준수한다.
	- POJO를 사용해 스레드를 아는코드와 모르는 코드로 분리한다
- 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다 
- 사용하는 라이브러리와 기본알고리즘을 이해한다
	- 라이브러리 기능이 기본 알고리즘과 유사한 어떤 문제를 어떻게 해결하는지 파악
- 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다.
	- 공유하는 정보와 공유하지 않는 정보를 제대로 이해해야함
	- 공유하는 객체 수와 범위를 최대한 줄인다.
	- 클라이언트에게 공유 상태를 관리하는 책임을 떠넘기지 않는다.
		- 필요시 객체 설계를 변경해 클라이언트에게 편의를 제공
- 어떻게는 문제가 생기므로 스레드 코드가 많은 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트 해야함

